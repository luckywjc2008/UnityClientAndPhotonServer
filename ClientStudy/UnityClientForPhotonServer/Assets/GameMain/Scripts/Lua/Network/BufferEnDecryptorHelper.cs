using UnityEngine;
using System.Collections;
using System.Runtime.InteropServices;
using System;
using StarForce;

public class BufferEnDecryptorHelper
{
    private byte m_cbSendRound;                        //字节映射
    private byte m_cbRecvRound;                        //字节映射

    private uint m_dwSendXorKey;                        //发送密钥
    private uint m_dwRecvXorKey;                     //接收密钥


    private uint m_dwSendPacketCount;               //发送计数
    public uint m_dwRecvPacketCount;               //接受计数

    //加密密钥
    private const uint g_dwPacketKey = 0xA55AA55A;

    //发送映射
    private byte[] g_SendByteMap =
    {
            0x70,0x2F,0x40,0x5F,0x44,0x8E,0x6E,0x45,0x7E,0xAB,0x2C,0x1F,0xB4,0xAC,0x9D,0x91,
            0x0D,0x36,0x9B,0x0B,0xD4,0xC4,0x39,0x74,0xBF,0x23,0x16,0x14,0x06,0xEB,0x04,0x3E,
            0x12,0x5C,0x8B,0xBC,0x61,0x63,0xF6,0xA5,0xE1,0x65,0xD8,0xF5,0x5A,0x07,0xF0,0x13,
            0xF2,0x20,0x6B,0x4A,0x24,0x59,0x89,0x64,0xD7,0x42,0x6A,0x5E,0x3D,0x0A,0x77,0xE0,
            0x80,0x27,0xB8,0xC5,0x8C,0x0E,0xFA,0x8A,0xD5,0x29,0x56,0x57,0x6C,0x53,0x67,0x41,
            0xE8,0x00,0x1A,0xCE,0x86,0x83,0xB0,0x22,0x28,0x4D,0x3F,0x26,0x46,0x4F,0x6F,0x2B,
            0x72,0x3A,0xF1,0x8D,0x97,0x95,0x49,0x84,0xE5,0xE3,0x79,0x8F,0x51,0x10,0xA8,0x82,
            0xC6,0xDD,0xFF,0xFC,0xE4,0xCF,0xB3,0x09,0x5D,0xEA,0x9C,0x34,0xF9,0x17,0x9F,0xDA,
            0x87,0xF8,0x15,0x05,0x3C,0xD3,0xA4,0x85,0x2E,0xFB,0xEE,0x47,0x3B,0xEF,0x37,0x7F,
            0x93,0xAF,0x69,0x0C,0x71,0x31,0xDE,0x21,0x75,0xA0,0xAA,0xBA,0x7C,0x38,0x02,0xB7,
            0x81,0x01,0xFD,0xE7,0x1D,0xCC,0xCD,0xBD,0x1B,0x7A,0x2A,0xAD,0x66,0xBE,0x55,0x33,
            0x03,0xDB,0x88,0xB2,0x1E,0x4E,0xB9,0xE6,0xC2,0xF7,0xCB,0x7D,0xC9,0x62,0xC3,0xA6,
            0xDC,0xA7,0x50,0xB5,0x4B,0x94,0xC0,0x92,0x4C,0x11,0x5B,0x78,0xD9,0xB1,0xED,0x19,
            0xE9,0xA1,0x1C,0xB6,0x32,0x99,0xA3,0x76,0x9E,0x7B,0x6D,0x9A,0x30,0xD6,0xA9,0x25,
            0xC7,0xAE,0x96,0x35,0xD0,0xBB,0xD2,0xC8,0xA2,0x08,0xF3,0xD1,0x73,0xF4,0x48,0x2D,
            0x90,0xCA,0xE2,0x58,0xC1,0x18,0x52,0xFE,0xDF,0x68,0x98,0x54,0xEC,0x60,0x43,0x0F
        };

    //接收映射
    private byte[] g_RecvByteMap =
    {
    0x51,0xA1,0x9E,0xB0,0x1E,0x83,0x1C,0x2D,0xE9,0x77,0x3D,0x13,0x93,0x10,0x45,0xFF,
    0x6D,0xC9,0x20,0x2F,0x1B,0x82,0x1A,0x7D,0xF5,0xCF,0x52,0xA8,0xD2,0xA4,0xB4,0x0B,
    0x31,0x97,0x57,0x19,0x34,0xDF,0x5B,0x41,0x58,0x49,0xAA,0x5F,0x0A,0xEF,0x88,0x01,
    0xDC,0x95,0xD4,0xAF,0x7B,0xE3,0x11,0x8E,0x9D,0x16,0x61,0x8C,0x84,0x3C,0x1F,0x5A,
    0x02,0x4F,0x39,0xFE,0x04,0x07,0x5C,0x8B,0xEE,0x66,0x33,0xC4,0xC8,0x59,0xB5,0x5D,
    0xC2,0x6C,0xF6,0x4D,0xFB,0xAE,0x4A,0x4B,0xF3,0x35,0x2C,0xCA,0x21,0x78,0x3B,0x03,
    0xFD,0x24,0xBD,0x25,0x37,0x29,0xAC,0x4E,0xF9,0x92,0x3A,0x32,0x4C,0xDA,0x06,0x5E,
    0x00,0x94,0x60,0xEC,0x17,0x98,0xD7,0x3E,0xCB,0x6A,0xA9,0xD9,0x9C,0xBB,0x08,0x8F,
    0x40,0xA0,0x6F,0x55,0x67,0x87,0x54,0x80,0xB2,0x36,0x47,0x22,0x44,0x63,0x05,0x6B,
    0xF0,0x0F,0xC7,0x90,0xC5,0x65,0xE2,0x64,0xFA,0xD5,0xDB,0x12,0x7A,0x0E,0xD8,0x7E,
    0x99,0xD1,0xE8,0xD6,0x86,0x27,0xBF,0xC1,0x6E,0xDE,0x9A,0x09,0x0D,0xAB,0xE1,0x91,
    0x56,0xCD,0xB3,0x76,0x0C,0xC3,0xD3,0x9F,0x42,0xB6,0x9B,0xE5,0x23,0xA7,0xAD,0x18,
    0xC6,0xF4,0xB8,0xBE,0x15,0x43,0x70,0xE0,0xE7,0xBC,0xF1,0xBA,0xA5,0xA6,0x53,0x75,
    0xE4,0xEB,0xE6,0x85,0x14,0x48,0xDD,0x38,0x2A,0xCC,0x7F,0xB1,0xC0,0x71,0x96,0xF8,
    0x3F,0x28,0xF2,0x69,0x74,0x68,0xB7,0xA3,0x50,0xD0,0x79,0x1D,0xFC,0xCE,0x8A,0x8D,
    0x2E,0x62,0x30,0xEA,0xED,0x2B,0x26,0xB9,0x81,0x7C,0x46,0x89,0x73,0xA2,0xF7,0x72
};

    //随机映射
    ushort SeedRandMap(ushort wSeed)
    {
        uint dwHold = wSeed;
        return (ushort)((dwHold = (uint)(dwHold * 241103L + 2533101L) >> 16));
    }

    /// 获取时间戳  
    /// </summary>  
    /// <returns></returns>  
    public uint GetTimeStamp()
    {
        TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);
        return Convert.ToUInt32(ts.TotalSeconds);
    }

    //映射发送数据
    private byte MapSendByte(byte cbData)
    {
        byte cbMap = (byte)g_SendByteMap[(byte)(cbData + m_cbSendRound)];
        m_cbSendRound += 3;
        return cbMap;
    }

    //映射接收数据
    private byte MapRecvByte(byte cbData)
    {

        byte cbMap = (byte)(g_RecvByteMap[cbData] - m_cbRecvRound);
        m_cbRecvRound += 3;
        return cbMap;
    }

    public ushort EncryptBuffer(byte[] pcbDataBuffer, ushort wDataSize)
    {
        //调整长度
        ushort wEncrptySize = (ushort)(wDataSize - 4);
        ushort wSnapCount = 0;
        if ((wEncrptySize % 4 != 0))
        {
            wSnapCount = (ushort)(4 - wEncrptySize % 4);
        }

        //校验码与字节映射
        byte cbCheckCode = 0;
        ushort i = 0;
        for (i = 4; i < wDataSize; i++)
        {
            cbCheckCode += pcbDataBuffer[i];
            pcbDataBuffer[i] = MapSendByte(pcbDataBuffer[i]);
        }

        //填写信息头
        TCP_Info tcpHead = new TCP_Info();
        tcpHead.cbCheckCode = (byte)(~cbCheckCode + 1);
        tcpHead.wPacketSize = wDataSize;
        tcpHead.cbDataKind = 0x02;
        int tcpHeadSize = System.Runtime.InteropServices.Marshal.SizeOf(tcpHead);
        byte[] headBuffer = StructBytesInterop.StructureToByteArraySmallEndian(tcpHead);
        System.Buffer.BlockCopy(headBuffer, 0, pcbDataBuffer, 0, tcpHeadSize);

        //创建密钥
        uint dwXorKey = m_dwSendXorKey;
        if (m_dwSendPacketCount == 0)
        {
            //随机映射种子
            dwXorKey = GetTimeStamp();
            dwXorKey = SeedRandMap((ushort)dwXorKey);
            dwXorKey |= ((uint)SeedRandMap((ushort)(dwXorKey >> 16))) << 16;
            dwXorKey ^= g_dwPacketKey;
            m_dwSendXorKey = dwXorKey;
            m_dwRecvXorKey = dwXorKey;

        }

        //加密数据
        ushort pwSeed = 4;
        uint pdwXor = 4;

        ushort wEncryptCount = (ushort)((wEncrptySize + wSnapCount) / 4);
        for (ushort j = 0; j < wEncryptCount; j++)
        {
            uint tempX = BitConverter.ToUInt32(pcbDataBuffer, (int)pdwXor);
            tempX ^= dwXorKey;
            byte[] tempBuffer = BitConverter.GetBytes(tempX);
            System.Buffer.BlockCopy(tempBuffer, 0, pcbDataBuffer, (int)pdwXor, 4);
            pdwXor += 4;

            ushort tempSeed = BitConverter.ToUInt16(pcbDataBuffer, (int)pwSeed);
            dwXorKey = SeedRandMap(tempSeed);
            pwSeed += 2;
            tempSeed = BitConverter.ToUInt16(pcbDataBuffer, (int)pwSeed);
            dwXorKey |= (uint)(SeedRandMap(tempSeed) << 16);
            pwSeed += 2;
            dwXorKey ^= g_dwPacketKey;
        }

        //插入密钥
        if (m_dwSendPacketCount == 0)
        {
            System.Buffer.BlockCopy(pcbDataBuffer, 8, pcbDataBuffer, 12, wDataSize);
            byte[] keyBuffer = System.BitConverter.GetBytes(m_dwSendXorKey);
            System.Buffer.BlockCopy(keyBuffer, 0, pcbDataBuffer, 8, 4);

            tcpHead.wPacketSize += 4;
            headBuffer = StructBytesInterop.StructureToByteArraySmallEndian(tcpHead);
            System.Buffer.BlockCopy(headBuffer, 0, pcbDataBuffer, 0, tcpHeadSize);

            wDataSize += 4;
        }

        m_dwSendPacketCount++;
        m_dwSendXorKey = dwXorKey;

        return wDataSize;
    }

    public ushort DecryptBuffer(byte[] pcbDataBuffer, ushort wDataSize)
    {
        //调整长度
        ushort wSnapCount = 0;
        if (wDataSize % 4 != 0)
        {
            wSnapCount = (ushort)(4 - wDataSize % 4);
        }

        //提取密钥
        if (m_dwRecvPacketCount == 0)
        {
            if (wDataSize < 12)
                return 0;

            m_dwRecvXorKey = BitConverter.ToUInt32(pcbDataBuffer, 8);
            m_dwSendXorKey = m_dwRecvXorKey;
            System.Buffer.BlockCopy(pcbDataBuffer, 12, pcbDataBuffer, 8, wDataSize - 12);
            ushort oldPacketSize = BitConverter.ToUInt16(pcbDataBuffer, 2);
            BitConverter.GetBytes(oldPacketSize - 4).CopyTo(pcbDataBuffer, 2);
        }

        //解密数据
        uint dwXorKey = m_dwRecvXorKey;
        uint pdwXor = 4;
        ushort pwSeed = 4;
        ushort wEncryptCount = (ushort)((wDataSize + wSnapCount - 4) / 4);
        for (ushort i = 0; i < wEncryptCount; i++)
        {
            if ((i == (wEncryptCount - 1)) && (wSnapCount > 0))
            {
                byte pcbKey = (byte)(4 - wSnapCount);
                byte[] recvXorKeyBytes = BitConverter.GetBytes(m_dwRecvXorKey);
                System.Buffer.BlockCopy(recvXorKeyBytes, pcbKey, pcbDataBuffer, wDataSize, wSnapCount);
            }
            ushort tempUShort = BitConverter.ToUInt16(pcbDataBuffer, pwSeed);
            dwXorKey = SeedRandMap(tempUShort);
            pwSeed += 2;

            tempUShort = BitConverter.ToUInt16(pcbDataBuffer, pwSeed);
            dwXorKey |= ((uint)SeedRandMap(tempUShort)) << 16;
            pwSeed += 2;

            dwXorKey ^= g_dwPacketKey;

            uint tempUInt = BitConverter.ToUInt32(pcbDataBuffer, (int)pdwXor);
            tempUInt ^= m_dwRecvXorKey;
            byte[] temUIntBuffer = BitConverter.GetBytes(tempUInt);
            System.Buffer.BlockCopy(temUIntBuffer, 0, pcbDataBuffer, (int)pdwXor, 4);
            pdwXor += 4;

            m_dwRecvXorKey = dwXorKey;
        }

        //校验码与字节映射
        byte cbCheckCode = pcbDataBuffer[1];
        for (int i = 4; i < wDataSize; i++)
        {
            pcbDataBuffer[i] = MapRecvByte(pcbDataBuffer[i]);

            cbCheckCode += pcbDataBuffer[i];
        }

        if (cbCheckCode != 0)
            return 0;

        return wDataSize;
    }

    public void initValue()
    {
        m_cbSendRound = 0;                        //字节映射
        m_cbRecvRound = 0;                        //字节映射

        m_dwSendXorKey = 0;                        //发送密钥
        m_dwRecvXorKey = 0;                     //接收密钥

        m_dwSendPacketCount = 0;            //发送计数
        m_dwRecvPacketCount = 0;            //接受计数
    }
}